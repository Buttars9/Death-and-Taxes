---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\anchorToVault.js ---- 
// shared/utils/anchorToVault.js

import crypto from 'crypto';

/**
 * Anchors final payload and PDF to backend vault.
 * Generates SHA-256 hash, logs metadata, and prepares for blockchain anchoring.
 */

export async function anchorToVault({ payload, pdfBuffer, userId }) {
  if (!payload || !pdfBuffer || !userId) {
    throw new Error('Missing required vault anchoring inputs');
  }

  const payloadHash = crypto.createHash('sha256').update(JSON.stringify(payload)).digest('hex');
  const pdfHash = crypto.createHash('sha256').update(pdfBuffer).digest('hex');
  const timestamp = new Date().toISOString();

  const vaultRecord = {
    userId,
    timestamp,
    payloadHash,
    pdfHash,
    auditTag: 'final_submission_anchored',
  };

  try {
    const res = await fetch('/api/vault/anchor', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(vaultRecord),
    });

    if (!res.ok) {
      throw new Error(`Vault anchoring failed: ${res.status}`);
    }

    return await res.json();
  } catch (err) {
    console.error('âŒ Vault anchoring error:', err);
    throw err;
  }
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\buildIrsPayload.js ---- 
import { formMapping } from '../../frontend/src/questions/formMapping.js';

export function buildIrsPayload(validatedAnswers) {
  const payload = {
    forms: {},
    metadata: {
      timestamp: new Date().toISOString(),
      source: 'Powered by Pi - Death & Taxes',
    },
  };

  Object.entries(validatedAnswers).forEach(([key, value]) => {
    const lookupKey = key.startsWith('incomeSources.') ? key.split('.')[1] : key;
    const meta = formMapping[lookupKey];

    if (!meta || !meta.form || !meta.line) return;

    if (!payload.forms[meta.form]) {
      payload.forms[meta.form] = {};
    }

    payload.forms[meta.form][meta.line] = value;
  });

  return payload;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\calculateRefund.js ---- 
import { OBBBA_LAW } from './lawSync.js';
import { getStateCredits } from './creditsByState.js';

export function calculateRefund({
  state,
  filingStatus,
  income,
  dependents,
  age,
  tipIncome = 0,
  overtimeIncome = 0,
  saltPaid = 0,
  assets = [],
  deductionType = 'standard',
  deductions = [],
  credits = [],
  taxWithheld = 0,
  estimatedPayments = 0,
}) {
  // ðŸ§® AGI = income (simplified for now)
  const agi = income;

  // ðŸ§¾ Deductions
  const standardDeductionMap = {
    single: 13850,
    married: 27700,
    headOfHousehold: 20800,
  };

  const standardDeduction = standardDeductionMap[filingStatus] || 13850;
  const itemizedDeduction = deductions.length * 1000; // Simplified
  const deductionAmount =
    deductionType === 'itemized' ? itemizedDeduction : standardDeduction;

  // ðŸ§® Taxable income
  const taxableIncome = Math.max(agi - deductionAmount, 0);

  // ðŸ§¾ IRS Tax Brackets (2024 simplified)
  const taxBrackets = {
    single: [
      { upTo: 11000, rate: 0.10 },
      { upTo: 44725, rate: 0.12 },
      { upTo: 95375, rate: 0.22 },
    ],
    married: [
      { upTo: 22000, rate: 0.10 },
      { upTo: 89450, rate: 0.12 },
      { upTo: 190750, rate: 0.22 },
    ],
    headOfHousehold: [
      { upTo: 15700, rate: 0.10 },
      { upTo: 59850, rate: 0.12 },
      { upTo: 95350, rate: 0.22 },
    ],
  };

  const brackets = taxBrackets[filingStatus] || [];
  let remaining = taxableIncome;
  let taxOwed = 0;

  for (let i = 0; i < brackets.length; i++) {
    const { upTo, rate } = brackets[i];
    const prevUpTo = i === 0 ? 0 : brackets[i - 1].upTo;
    const slice = Math.min(remaining, upTo - prevUpTo);
    if (slice > 0) {
      taxOwed += slice * rate;
      remaining -= slice;
    }
  }

  // ðŸ’¸ Credits
  const creditAmount = credits.length * 1000; // Simplified

  // ðŸ’° Payments
  const totalPayments = taxWithheld + estimatedPayments;

  // ðŸ§  OBBBA Enhancements
  const tipDeduction = Math.min(tipIncome, OBBBA_LAW.thresholds.tipDeductionCap);
  const overtimeDeduction = Math.min(overtimeIncome, OBBBA_LAW.thresholds.overtimeDeductionCap);

  const seniorBonus =
    age >= 65
      ? filingStatus === 'married'
        ? OBBBA_LAW.thresholds.seniorBonusDeduction.married
        : OBBBA_LAW.thresholds.seniorBonusDeduction.single
      : 0;

  const saltAdjustment =
    income < 500000 ? Math.min(saltPaid, OBBBA_LAW.thresholds.saltCap) : 0;

  const assetDeduction = assets.reduce((total, asset) => {
    if (asset.type === 'equipment' && asset.value <= OBBBA_LAW.thresholds.section179Limit) {
      return total + asset.value;
    }
    return total;
  }, 0);

  const bonusDepreciation = assetDeduction * OBBBA_LAW.thresholds.bonusDepreciation;

  const stateCredits = getStateCredits(state);
  const stateCreditTotal = stateCredits.reduce((sum, credit) => sum + credit.amount, 0);

  // ðŸ§¾ Final refund calculation
  const totalAdjustments =
    creditAmount +
    totalPayments +
    tipDeduction +
    overtimeDeduction +
    seniorBonus +
    saltAdjustment +
    bonusDepreciation +
    stateCreditTotal;

  const refund = Math.max(totalAdjustments - taxOwed, 0);
  const balanceDue = Math.max(taxOwed - totalAdjustments, 0);

  return {
    agi,
    deductionAmount,
    deductionType,
    taxableIncome,
    taxOwed,
    creditAmount,
    totalPayments,
    refund,
    balanceDue,
    tipDeduction,
    overtimeDeduction,
    seniorBonus,
    saltAdjustment,
    bonusDepreciation,
    stateCredits,
    stateCreditTotal,
    notes: 'Refund calculated using IRS brackets, credits, payments, and OBBBA thresholds.',
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\creditEngine.js ---- 
export function getEligibleCredits({
  income,
  dependents,
  filingStatus,
  capitalGains = 0,
  retirementIncome = 0,
  foreignAssets = [],
  autoLoanInterest = 0,
  age,
}) {
  const THRESHOLDS = {
    childTaxCreditHighIncome: 200000,
    earnedIncomeCreditLimit: 45000,
    educationCreditLimit: 80000,
    amtTrigger: { married: 200000, single: 125000 },
    capitalGainsCreditLimit: 100000,
    retirementExclusionCap: 10000,
    autoLoanDeductionCap: 2500,
    autoLoanIncomeLimit: 150000,
  };

  const credits = [];

  // ðŸ’° Child Tax Credit
  if (dependents > 0) {
    const baseCTC =
      income < THRESHOLDS.childTaxCreditHighIncome ? 2000 : 1000;
    credits.push({ type: 'CTC', amount: dependents * baseCTC });
  }

  // ðŸ¥ Earned Income Credit
  if (income < THRESHOLDS.earnedIncomeCreditLimit && filingStatus === 'single') {
    credits.push({ type: 'EIC', amount: 500 });
  }

  // ðŸŽ“ Education Credit
  if (income < THRESHOLDS.educationCreditLimit) {
    credits.push({ type: 'EDU', amount: 1000 });
  }

  // ðŸ§  AMT Trigger
  const amtThreshold = THRESHOLDS.amtTrigger[filingStatus] ?? 125000;
  if (income > amtThreshold && capitalGains > 50000) {
    credits.push({
      type: 'AMT Warning',
      amount: 0,
      note: 'Potential AMT trigger',
    });
  }

  // ðŸ“ˆ Capital Gains Threshold
  if (capitalGains > 0 && income < THRESHOLDS.capitalGainsCreditLimit) {
    credits.push({ type: 'Capital Gains Credit', amount: 250 });
  }

  // ðŸ§“ Retirement Income Exclusion
  if (retirementIncome > 0 && age >= 65) {
    const exclusion = Math.min(
      retirementIncome,
      THRESHOLDS.retirementExclusionCap
    );
    credits.push({ type: 'Retirement Exclusion', amount: exclusion });
  }

  // ðŸŒ Foreign Asset Disclosure
  if (foreignAssets.length > 0) {
    credits.push({
      type: 'Foreign Asset Disclosure',
      amount: 0,
      note: `${foreignAssets.length} foreign assets flagged for review`,
    });
  }

  // ðŸš— Auto Loan Interest Deduction
  if (autoLoanInterest > 0 && income < THRESHOLDS.autoLoanIncomeLimit) {
    const deduction = Math.min(
      autoLoanInterest,
      THRESHOLDS.autoLoanDeductionCap
    );
    credits.push({ type: 'Auto Loan Deduction', amount: deduction });
  }

  return credits
    .map((credit) => ({
      ...credit,
      eligible: credit.amount > 0 || !!credit.note,
    }))
    .sort((a, b) => a.type.localeCompare(b.type));
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\creditsByState.js ---- 
// shared/utils/creditsByState.js

export function getStateCredits(state) {
  const credits = {
    CA: [
      { name: 'Renters Credit', amount: 60 },
      { name: 'Child Care Credit', amount: 200 },
    ],
    TX: [
      { name: 'Property Tax Relief', amount: 150 },
    ],
    NY: [
      { name: 'Earned Income Credit', amount: 250 },
      { name: 'College Tuition Credit', amount: 300 },
    ],
    FL: [],
    // Add more states as needed
  };

  return credits[state] || [];
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\deductionsByState.js ---- 
// death-and-taxes/src/utils/deductionsByState.js

// Simplified deduction logic scaffold for all 50 states
// This will expand over time with credits, thresholds, and edge cases

export const deductionsByState = {
  Alabama: {
    standardDeduction: 4000,
    notes: 'Itemized allowed if higher than standard. No grocery credit.',
  },
  Alaska: {
    standardDeduction: 0,
    notes: 'No state income tax.',
  },
  Arizona: {
    standardDeduction: 12500,
    notes: 'Matches federal. Allows itemized deductions.',
  },
  // ... full list continues
  Wisconsin: {
    standardDeduction: 10000,
    notes: 'Credits for renters, child care, and retirement.',
  },
  Wyoming: {
    standardDeduction: 0,
    notes: 'No state income tax.',
  }
};
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\deductionStrategy.js ---- 
// death-and-taxes/server/utils/deductionStrategy.js

export function determineDeductionStrategy(answers) {
  const { filingStatus, deductions = {}, agi = 0 } = answers;

  const standardDeductionMap = {
    single: 13850,
    married: 27700,
    headOfHousehold: 20800,
  };

  const standardAmount = standardDeductionMap[filingStatus] || 13850;

  const {
    mortgageInterest = 0,
    propertyTaxes = 0,
    stateIncomeTax = 0,
    charitableDonations = 0,
    educationExpenses = 0,
    childcareExpenses = 0,
    retirementContributions = 0,
    medicalExpenses = 0,
  } = deductions;

  const medicalThreshold = 0.075 * agi;
  const eligibleMedical = medicalExpenses > medicalThreshold ? medicalExpenses : 0;

  const itemizedTotal =
    mortgageInterest +
    propertyTaxes +
    stateIncomeTax +
    charitableDonations +
    educationExpenses +
    childcareExpenses +
    retirementContributions +
    eligibleMedical;

  const recommendedStrategy = itemizedTotal > standardAmount ? 'itemized' : 'standard';

  const reasoning =
    recommendedStrategy === 'itemized'
      ? `Your itemized deductions total $${itemizedTotal}, which exceeds the standard deduction of $${standardAmount}.`
      : `Standard deduction of $${standardAmount} is higher than your itemized total of $${itemizedTotal}.`;

  return {
    standardAmount,
    itemizedTotal,
    recommendedStrategy,
    reasoning,
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\deductionVerdictFromAnswers.js ---- 
// death-and-taxes/shared/utils/deductionVerdictFromAnswers.js

import { deductionsByState } from '../../src/utils/deductionsByState.js';

export default function deductionVerdictFromAnswers(answers) {
  const {
    income = 0,
    dependents = 0,
    filingStatus = 'single',
    itemizedDeductions = [],
    state = '',
  } = answers;

  const stateData = deductionsByState[state] || {};
  const standardAmount = stateData.standardDeduction || 0;

  const itemizedTotal = itemizedDeductions.reduce((sum, val) => sum + val.amount, 0);

  const recommendedStrategy =
    itemizedTotal > standardAmount ? 'itemized' : 'standard';

  const reasoning =
    recommendedStrategy === 'itemized'
      ? 'Your itemized deductions exceed the standard deduction.'
      : 'Standard deduction provides greater or equal benefit.';

  return {
    taxVerdict: {
      standardAmount,
      itemizedTotal,
      recommendedStrategy,
      reasoning,
      filingStatus, // âœ… Threaded for downstream logic or display
      dependents,   // âœ… Preserved for future child credit logic
      income,       // âœ… Preserved for AGI-based branching
    },
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\filingValidator.js ---- 
export function validateFilingData(data) {
  const errors = [];

  // Filing status
  if (!data.filingStatus) errors.push('Missing filing status');
  if (!['single', 'married', 'headOfHousehold', 'widow'].includes(data.filingStatus)) {
    errors.push('Invalid filing status');
  }

  // Income
  if (typeof data.income !== 'number') errors.push('Income must be a number');
  if (data.income < 0) errors.push('Income cannot be negative');
  if (data.income > 10000000) errors.push('Income exceeds supported range');

  // Age
  if (typeof data.age !== 'number') errors.push('Age must be a number');
  if (data.age < 0 || data.age > 120) errors.push('Invalid age');

  // Dependents
  if (!Array.isArray(data.dependents)) errors.push('Dependents must be an array');
  data.dependents?.forEach((dep, i) => {
    if (!dep.name || typeof dep.age !== 'number') {
      errors.push(`Dependent #${i + 1} is missing name or age`);
    }
  });

  // Tip/overtime
  if (typeof data.tipIncome !== 'number') errors.push('Tip income must be a number');
  if (data.tipIncome > 50000) errors.push('Tip income exceeds supported range');
  if (typeof data.overtimeIncome !== 'number') errors.push('Overtime income must be a number');
  if (data.overtimeIncome > 50000) errors.push('Overtime income exceeds supported range');

  // SALT
  if (typeof data.saltPaid !== 'number') errors.push('SALT paid must be a number');

  // Assets
  if (!Array.isArray(data.assets)) errors.push('Assets must be an array');
  data.assets?.forEach((asset, i) => {
    if (!asset.type || typeof asset.value !== 'number') {
      errors.push(`Asset #${i + 1} is invalid`);
    }
  });

  // Deductions
  if (!['standard', 'itemized'].includes(data.deductionType)) {
    errors.push('Deduction type must be standard or itemized');
  }
  if (!Array.isArray(data.deductions)) errors.push('Deductions must be an array');

  // Credits
  if (!Array.isArray(data.credits)) errors.push('Credits must be an array');

  // Withholding
  if (typeof data.taxWithheld !== 'number') errors.push('Tax withheld must be a number');
  if (typeof data.estimatedPayments !== 'number') errors.push('Estimated payments must be a number');

  // Prior AGI
  if (typeof data.priorAGI !== 'number') errors.push('Prior AGI must be a number');

  // IRS PIN
  if (data.irsPIN && !/^\d{6}$/.test(data.irsPIN)) {
    errors.push('IRS PIN must be 6 digits');
  }

  // Routing/account
  if (!/^\d{9}$/.test(data.routingNumber)) errors.push('Routing number must be 9 digits');
  if (!/^\d{4,17}$/.test(data.accountNumber)) errors.push('Account number must be 4â€“17 digits');

  // Trust confirmation
  if (data.trustConfirmed !== true) errors.push('Trust must be confirmed before submission');

  return errors;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\form1040PayLoad.js ---- 
// death-and-taxes/src/shared/utils/form1040Payload.js

export function buildForm1040Payload(answers) {
  if (!answers?.trustConfirmed) {
    throw new Error('âŒ Cannot build 1040 payload without trust confirmation.');
  }

  const {
    fullName,
    ssn,
    dob,
    address,
    maritalStatus,
    spouseName,
    spouseSSN,
    dependents = [],
    filingStatus,
    income = 0,
    priorAGI,
    irsPIN,
    foreignIncome,
    residentState,
    deductionType = 'standard',
    deductions = [],
    credits = [],
    estimatedRefund,
    contactEmail,
    submissionTimestamp,
  } = answers;

  // Map dependents
  const mappedDependents = dependents.map(dep => ({
    name: dep.name,
    ssn: dep.ssn,
    dob: dep.dob,
    relationship: dep.relationship,
  }));

  // Deductions
  const deductionAmount =
    deductionType === 'standard'
      ? getStandardDeduction(filingStatus)
      : deductions.length * 1000;

  // Credits
  const creditAmount = credits.length * 1000;

  return {
    metadata: {
      submittedAt: submissionTimestamp || new Date().toISOString(),
      confirmed: true,
      contactEmail: contactEmail || null,
      refundEstimate: estimatedRefund || null,
    },
    taxpayer: {
      fullName,
      ssn,
      dob,
      address,
      filingStatus,
      maritalStatus,
      spouse: maritalStatus === 'married_joint' ? {
        name: spouseName,
        ssn: spouseSSN,
      } : null,
      dependents: mappedDependents,
      residentState,
    },
    identityVerification: {
      priorAGI: priorAGI || null,
      irsPIN: irsPIN || null,
    },
    incomeDetails: {
      totalIncome: income,
      foreignIncome: !!foreignIncome,
    },
    deductions: {
      type: deductionType,
      items: deductionType === 'itemized' ? deductions : [],
      amount: deductionAmount,
    },
    credits: {
      items: credits,
      amount: creditAmount,
    },
    summary: {
      taxableIncome: Math.max(income - deductionAmount, 0),
      refundEstimate: estimatedRefund || null,
    },
  };
}

function getStandardDeduction(status) {
  const table = {
    single: 13850,
    married_joint: 27700,
    head: 20800,
  };
  return table[status] || 0;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generate1040Pdf.js ---- 
// death-and-taxes/shared/utils/generate1040Pdf.js

import jsPDF from 'jspdf';

/**
 * Generates a real IRS 1040-style PDF from structured refund data.
 * Layout mimics key lines from Form 1040.
 */

export function generate1040Pdf(refundData) {
  const doc = new jsPDF();
  let y = 20;

  doc.setFont('helvetica');
  doc.setFontSize(16);
  doc.text('Form 1040 - U.S. Individual Income Tax Return (Simplified)', 20, y);
  y += 10;

  doc.setFontSize(12);
  doc.text(`Filing Status: ${refundData.filingStatus || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Adjusted Gross Income (AGI): $${refundData.agi?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Deductions (${refundData.deductionType}): $${refundData.deductionAmount?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Taxable Income: $${refundData.taxableIncome?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Tax Owed: $${refundData.taxOwed?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Credits: $${refundData.creditAmount?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Payments (Withheld + Estimated): $${refundData.totalPayments?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Refund: $${refundData.refund?.toLocaleString() || '0'}`, 20, y);
  y += 8;

  doc.text(`Balance Due: $${refundData.balanceDue?.toLocaleString() || '0'}`, 20, y);
  y += 8;

  doc.text(`State Credits: $${refundData.stateCreditTotal?.toLocaleString() || 'â€”'}`, 20, y);
  y += 8;

  doc.text(`Notes: ${refundData.notes || 'â€”'}`, 20, y);
  y += 10;

  doc.setFontSize(10);
  doc.text('This document is a simplified representation of IRS Form 1040 for preview purposes only.', 20, y);

  return doc;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateEfileXml.js ---- 
// shared/utils/generateEfileXml.js

/**
 * Generates IRS e-file XML payload from validated answers.
 * This is a simplified version for future schema integration.
 */

export function generateEfileXml(answers) {
  const {
    filingStatus,
    income,
    deductionType,
    deductions = [],
    credits = [],
    taxWithheld,
    estimatedPayments,
    priorAGI,
    irsPIN,
    routingNumber,
    accountNumber,
    trustConfirmed,
  } = answers;

  const xml = `
<IRSSubmission>
  <FilingStatus>${filingStatus}</FilingStatus>
  <Income>${income}</Income>
  <DeductionType>${deductionType}</DeductionType>
  <Deductions>
    ${deductions.map((d) => `<Deduction>${d}</Deduction>`).join('\n    ')}
  </Deductions>
  <Credits>
    ${credits.map((c) => `<Credit>${c}</Credit>`).join('\n    ')}
  </Credits>
  <TaxWithheld>${taxWithheld}</TaxWithheld>
  <EstimatedPayments>${estimatedPayments}</EstimatedPayments>
  <PriorAGI>${priorAGI}</PriorAGI>
  <IRSPIN>${irsPIN || ''}</IRSPIN>
  <BankInfo>
    <RoutingNumber>${routingNumber}</RoutingNumber>
    <AccountNumber>${accountNumber}</AccountNumber>
  </BankInfo>
  <TrustConfirmed>${trustConfirmed ? 'true' : 'false'}</TrustConfirmed>
</IRSSubmission>
`.trim();

  return xml;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateFinalWill.js ---- 
import { v4 as uuidv4 } from 'uuid';

/**
 * Generates a full-text legal-style will based on filing data.
 * @param {Object} filing - User filing data
 * @returns {Object} will payload with ID, timestamp, and text
 */
function generateFinalWill(filing) {
  if (!filing || typeof filing !== 'object') {
    throw new Error('Missing or invalid filing data');
  }

  const consentTimestamp = new Date().toISOString();
  const filingId = uuidv4();

  const {
    estate = {},
    employmentType = 'â€”',
    willTemplate = 'Standard Template',
    hasDependents = false,
    state = 'â€”',
  } = filing;

  const {
    fullName = 'â€”',
    primaryBeneficiary = 'â€”',
    primaryBeneficiaryAge = 'â€”',
    guardianName = 'â€”',
    executor = 'â€”',
    assetSummary = 'â€”',
    finalWishes = 'â€”',
  } = estate;

  const templateVersion = 'v1.0';
  const legalVersion = '2025-US-Standard';
  const stateLawVersion = `2025-${state}-WillCode`;

  const signatoryLine = 'Signed,\n______________________';

  const willText = `
Last Will and Testament

I, ${fullName}, a resident of ${state}, hereby declare this to be my will.

Employment Status: ${employmentType}
Dependents: ${hasDependents ? 'Yes' : 'No'}
Primary Beneficiary: ${primaryBeneficiary} (Age: ${primaryBeneficiaryAge})
Executor: ${executor}
Guardian (if minor): ${guardianName}
Assets: ${assetSummary}
Final Wishes: ${finalWishes}

This document is based on template: ${willTemplate}
Template Version: ${templateVersion}
Legal Version: ${legalVersion}
State Law Reference: ${stateLawVersion}

[Further legal language and clauses would be inserted here.]

${signatoryLine}
`.trim();

  return {
    filingId,
    consentTimestamp,
    willText,
    templateVersion,
    legalVersion,
    stateLawVersion,
    signatoryLine,
  };
}

export { generateFinalWill };
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateIrsPdf.js ---- 
import jsPDF from 'jspdf';

export function generateIrsPdf(payload) {
  const doc = new jsPDF();

  doc.setFont('helvetica');
  doc.setFontSize(14);
  doc.text('IRS Filing Summary', 20, 20);

  doc.setFontSize(10);
  doc.text(`Generated: ${payload.metadata.timestamp}`, 20, 30);
  doc.text(`Source: ${payload.metadata.source}`, 20, 36);

  let y = 50;

  Object.entries(payload.forms).forEach(([form, lines]) => {
    doc.setFontSize(12);
    doc.text(`Form ${form}`, 20, y);
    y += 6;

    Object.entries(lines).forEach(([line, value]) => {
      doc.setFontSize(10);
      doc.text(`Line ${line}: ${String(value)}`, 30, y);
      y += 5;

      if (y > 280) {
        doc.addPage();
        y = 20;
      }
    });

    y += 8;
  });

  return doc;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateScheduleA.js ---- 
// shared/utils/generateScheduleA.js

import jsPDF from 'jspdf';

/**
 * Generates IRS Schedule A (Itemized Deductions) PDF.
 * Pulls from validated answers and formats line-by-line.
 */

export function generateScheduleA(answers) {
  const doc = new jsPDF();
  let y = 20;

  doc.setFont('helvetica');
  doc.setFontSize(16);
  doc.text('Schedule A - Itemized Deductions (Simplified)', 20, y);
  y += 10;

  const fields = [
    { label: 'Medical Expenses', key: 'medicalExpenses', line: '1' },
    { label: 'State Income Tax', key: 'stateIncomeTax', line: '5a' },
    { label: 'Property Taxes', key: 'propertyTaxes', line: '5b' },
    { label: 'Mortgage Interest', key: 'mortgageInterest', line: '8a' },
    { label: 'Charitable Donations', key: 'charitableDonations', line: '11' },
    { label: 'Education Expenses', key: 'educationExpenses', line: '21' },
    { label: 'Retirement Contributions', key: 'retirementContributions', line: '22' },
    { label: 'Other Deductions', key: 'otherDeductions', line: '23' },
  ];

  doc.setFontSize(12);
  fields.forEach(({ label, key, line }) => {
    const value = answers[key];
    if (value !== undefined && value !== null) {
      doc.text(`Line ${line}: ${label} â€” $${Number(value).toLocaleString()}`, 20, y);
      y += 8;
    }
  });

  const total = fields.reduce((sum, { key }) => {
    const val = answers[key];
    return sum + (typeof val === 'number' ? val : 0);
  }, 0);

  y += 4;
  doc.setFontSize(14);
  doc.text(`Total Itemized Deductions: $${total.toLocaleString()}`, 20, y);
  y += 10;

  doc.setFontSize(10);
  doc.text('This document is a simplified representation of IRS Schedule A for preview purposes only.', 20, y);

  return doc;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateScheduleC.js ---- 
// shared/utils/generateScheduleC.js

import jsPDF from 'jspdf';

/**
 * Generates IRS Schedule C (Profit or Loss from Business) PDF.
 * Pulls from validated answers and formats line-by-line.
 */

export function generateScheduleC(answers) {
  const doc = new jsPDF();
  let y = 20;

  doc.setFont('helvetica');
  doc.setFontSize(16);
  doc.text('Schedule C - Profit or Loss from Business (Simplified)', 20, y);
  y += 10;

  const fields = [
    { label: 'Gross Income (1099)', key: 'income', line: '1' },
    { label: 'Business Expenses', key: 'businessExpenses', line: '28' },
    { label: 'Home Office Deduction', key: 'homeOfficeDeduction', line: '30' },
    { label: 'Vehicle Expenses', key: 'vehicleExpenses', line: '9' },
    { label: 'Other Expenses', key: 'otherBusinessExpenses', line: '48' },
  ];

  doc.setFontSize(12);
  fields.forEach(({ label, key, line }) => {
    const value = answers[key];
    if (value !== undefined && value !== null) {
      doc.text(`Line ${line}: ${label} â€” $${Number(value).toLocaleString()}`, 20, y);
      y += 8;
    }
  });

  const income = answers.income || 0;
  const expenses = fields.reduce((sum, { key }) => {
    const val = answers[key];
    return sum + (typeof val === 'number' ? val : 0);
  }, 0);

  const netProfit = Math.max(income - expenses, 0);

  y += 4;
  doc.setFontSize(14);
  doc.text(`Net Profit: $${netProfit.toLocaleString()}`, 20, y);
  y += 10;

  doc.setFontSize(10);
  doc.text('This document is a simplified representation of IRS Schedule C for preview purposes only.', 20, y);

  return doc;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateScheduleD.js ---- 
// shared/utils/generateScheduleD.js

import jsPDF from 'jspdf';

/**
 * Generates IRS Schedule D (Capital Gains and Losses) PDF.
 * Pulls from validated answers and formats line-by-line.
 */

export function generateScheduleD(answers) {
  const doc = new jsPDF();
  let y = 20;

  doc.setFont('helvetica');
  doc.setFontSize(16);
  doc.text('Schedule D - Capital Gains and Losses (Simplified)', 20, y);
  y += 10;

  const fields = [
    { label: 'Short-Term Gains', key: 'shortTermGains', line: '1a' },
    { label: 'Short-Term Losses', key: 'shortTermLosses', line: '1b' },
    { label: 'Long-Term Gains', key: 'longTermGains', line: '8a' },
    { label: 'Long-Term Losses', key: 'longTermLosses', line: '8b' },
    { label: 'Crypto/Metals Gains', key: 'cryptoMetalsGains', line: '13' },
  ];

  doc.setFontSize(12);
  fields.forEach(({ label, key, line }) => {
    const value = answers[key];
    if (value !== undefined && value !== null) {
      doc.text(`Line ${line}: ${label} â€” $${Number(value).toLocaleString()}`, 20, y);
      y += 8;
    }
  });

  const gains = (answers.shortTermGains || 0) + (answers.longTermGains || 0) + (answers.cryptoMetalsGains || 0);
  const losses = (answers.shortTermLosses || 0) + (answers.longTermLosses || 0);
  const netGain = gains - losses;

  y += 4;
  doc.setFontSize(14);
  doc.text(`Net Capital Gain/Loss: $${netGain.toLocaleString()}`, 20, y);
  y += 10;

  doc.setFontSize(10);
  doc.text('This document is a simplified representation of IRS Schedule D for preview purposes only.', 20, y);

  return doc;
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\generateWillPDF.js ---- 
import PDFDocument from 'pdfkit';
import fs from 'fs';
import { generateFinalWill } from './generateFinalWill.js';

function generateWillPDF(filing, outputPath) {
  const doc = new PDFDocument();
  const {
    willText,
    filingId,
    consentTimestamp,
    templateVersion,
    legalVersion,
    stateLawVersion,
    signatoryLine,
  } = generateFinalWill(filing);

  doc.pipe(fs.createWriteStream(outputPath));

  // Header
  doc.fontSize(16).text('Last Will and Testament', { align: 'center' });
  doc.moveDown();

  // Body
  doc.fontSize(12).text(willText.trim(), {
    align: 'left',
    lineGap: 4,
  });
  doc.moveDown();

  // Signature line
  doc.fontSize(12).text(signatoryLine, { align: 'left' });
  doc.moveDown();

  // Footer metadata
  doc.fontSize(10).fillColor('gray');
  doc.text(`Filing ID: ${filingId}`);
  doc.text(`Consent Timestamp: ${consentTimestamp}`);
  doc.text(`Template Version: ${templateVersion}`);
  doc.text(`Legal Version: ${legalVersion}`);
  doc.text(`State Law Reference: ${stateLawVersion}`);

  doc.end();
}

export { generateWillPDF };
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\lawSync.js ---- 
// shared/utils/lawSync.js

export const OBBBA_LAW = {
  year: 2025,
  thresholds: {
    bonusDepreciation: 1.0, // 100%
    section179Limit: 2500000,
    section179PhaseOut: 4000000,
    tipDeductionCap: 25000,
    overtimeDeductionCap: 12500,
    saltCap: 40000,
    seniorBonusDeduction: {
      single: 6000,
      married: 12000,
    },
  },
  notes: [
    "QSBS holding period reduced to 3 years",
    "SALT cap raised for incomes under $500K",
    "Senior bonus deduction applies at age 65+",
  ],
};
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\refundEngine.js ---- 
import { deductionsByState } from '../../server/data/deductionsByState.js';
import { getEligibleCredits } from './creditEngine.js';

/**
 * Calculates refund estimate based on user inputs and current tax rules.
 * @param {Object} params
 * @param {string} params.state - User's selected state
 * @param {string} params.filingStatus - e.g. 'single', 'married'
 * @param {number} params.income - Annual income
 * @param {number} params.dependents - Number of dependents
 * @returns {Object} refund estimate
 */
export function calculateRefund({ state, filingStatus, income, dependents }) {
  if (!state || typeof state !== 'string') {
    throw new Error('Missing or invalid state');
  }
  if (!filingStatus || typeof filingStatus !== 'string') {
    throw new Error('Missing or invalid filing status');
  }
  if (typeof income !== 'number' || income < 0) {
    throw new Error('Invalid income');
  }
  if (typeof dependents !== 'number' || dependents < 0) {
    throw new Error('Invalid dependents');
  }

  const stateData = deductionsByState[state] || {};
  const deductionBoost = stateData.standardDeduction ?? 0;
  const notes = stateData.notes ?? '';

  // Federal logic
  const FEDERAL_BASE = 1500;
  const DEPENDENT_CREDIT = 2200;
  const LOW_INCOME_THRESHOLD = 75000;
  const LOW_INCOME_BONUS = 500;

  const dependentBoost = dependents * DEPENDENT_CREDIT;
  const lowIncomeBoost = income < LOW_INCOME_THRESHOLD ? LOW_INCOME_BONUS : 0;

  // ðŸ§® New branching credits
  const branchingCredits = getEligibleCredits({ income, dependents, filingStatus });
  const branchingTotal = branchingCredits.reduce((sum, c) => sum + c.amount, 0);
  const creditEngineVersion = 'v1.0';

  const total =
    FEDERAL_BASE + dependentBoost + lowIncomeBoost + deductionBoost + branchingTotal;

  return {
    state,
    filingStatus,
    income,
    dependents,
    deduction: deductionBoost,
    notes,
    creditEngineVersion,
    branchingTotal,
    credits: [
      { label: 'Federal Base Credit', amount: FEDERAL_BASE },
      { label: 'Dependent Credit', amount: dependentBoost },
      ...(lowIncomeBoost > 0 ? [{ label: 'Low Income Bonus', amount: lowIncomeBoost }] : []),
      ...(deductionBoost > 0 ? [{ label: 'State Deduction', amount: deductionBoost }] : []),
      ...branchingCredits.map(c => ({ label: c.type + ' Credit', amount: c.amount })),
    ],
    total,
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\validateAnswers.js ---- 
import { formMapping } from '../../frontend/src/questions/formMapping.js';

export function validateAnswers(answers) {
  const issues = [];
  const validated = {};

  // Validate standard fields
  for (const [key, meta] of Object.entries(formMapping)) {
    const value = answers[key];

    if (value === undefined || value === null || value === '') {
      issues.push({
        key,
        label: meta.label,
        reason: 'Missing required value',
        form: meta.form,
        line: meta.line,
      });
    } else {
      validated[key] = {
        value,
        form: meta.form,
        line: meta.line,
        label: meta.label,
      };
    }
  }

  // Validate income sources
  const selectedIncome = answers.incomeSources || [];

  for (const source of selectedIncome) {
    const meta = formMapping[source];
    if (!meta) {
      issues.push({
        key: `incomeSources.${source}`,
        label: source,
        reason: 'Unknown income type',
      });
      continue;
    }

    validated[`incomeSources.${source}`] = {
      value: true,
      form: meta.form,
      line: meta.line,
      label: meta.label,
    };
  }

  // Check for unmapped income sources
  const allMappedIncomeKeys = Object.keys(formMapping);
  const unmappedIncome = selectedIncome.filter(
    (src) => !allMappedIncomeKeys.includes(src)
  );

  for (const src of unmappedIncome) {
    issues.push({
      key: `incomeSources.${src}`,
      label: src,
      reason: 'Not mapped to IRS form',
    });
  }

  return {
    isValid: issues.length === 0,
    issues,
    validatedAnswers: validated,
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\validateSession.js ---- 
import axios from 'axios';

export async function validateSession(email, password) {
  try {
    const response = await axios.post('/api/login', {
      email,
      password,
    });

    const timestamp = new Date().toISOString();
    const statusCode = response.status;
    const authVersion = 'v1.0';

    if (response.data?.success) {
      return {
        success: true,
        user: response.data.user,
        token: response.data.token,
        timestamp,
        statusCode,
        authVersion,
      };
    } else {
      return {
        success: false,
        error: response.data?.error || 'Invalid credentials',
        timestamp,
        statusCode,
        authVersion,
      };
    }
  } catch (err) {
    return {
      success: false,
      error: err.response?.data?.error || 'Server error',
      timestamp: new Date().toISOString(),
      statusCode: err.response?.status || 500,
      authVersion: 'v1.0',
    };
  }
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\validators.js ---- 
export function validateFilingPayload(payload) {
  const requiredFields = [
    'filingStatus',
    'incomeSources',
    'deductions',
    'credits',
    'routingNumber',
    'accountNumber',
    'trustConfirmed',
  ];

  const fieldErrors = [];
  const validatedAt = new Date().toISOString();
  const payloadVersion = 'v1.0';

  for (const field of requiredFields) {
    const value = payload[field];

    if (!payload.hasOwnProperty(field)) {
      fieldErrors.push(`Missing required field: ${field}`);
      continue;
    }

    if (['incomeSources', 'deductions', 'credits'].includes(field)) {
      if (!Array.isArray(value)) {
        fieldErrors.push(`Field ${field} must be an array`);
      }
    } else if (value === '' || value === null || value === undefined) {
      fieldErrors.push(`Field ${field} cannot be empty`);
    }
  }

  if (payload.trustConfirmed !== true) {
    fieldErrors.push('User must confirm trust before submission');
  }

  if (fieldErrors.length > 0) {
    return {
      valid: false,
      message: 'Payload validation failed',
      fieldErrors,
      validatedAt,
      payloadVersion,
    };
  }

  return {
    valid: true,
    validatedAt,
    payloadVersion,
  };
}
---- FILE: C:\Users\austi\OneDrive\Desktop\Powered by PI\death and taxes\shared\utils\willifyAnswers.js ---- 
import { determineDeductionStrategy } from './deductionStrategy.js';
import { calculateRefund } from './calculateRefund.js';

export function willifyAnswers(answers) {
  const {
    name = 'Unnamed',
    state = 'Unknown',
    employmentType,
    dependents,
    assets,
    deductions = {},
    filingStatus,
    agi,
  } = answers;

  const hasDependents = Array.isArray(dependents) && dependents.length > 0;
  const hasAssets = Array.isArray(assets) && assets.length > 0;

  const baseWill = {
    name,
    state,
    employmentType,
    provisions: [],
    willVersion: 'v1.0',
    generatedAt: new Date().toISOString(),
  };

  if (hasDependents) {
    baseWill.provisions.push('Include guardianship and minor trust provisions.');
  }

  if (hasAssets) {
    baseWill.provisions.push('Include asset distribution and estate transfer clauses.');
  }

  const taxVerdict = determineDeductionStrategy({
    filingStatus,
    deductions,
    agi,
  });

  const refundEstimate = calculateRefund({
    state,
    filingStatus,
    income: agi,
    dependents: hasDependents ? dependents.length : 0,
  });

  return {
    ...baseWill,
    taxVerdict,
    refundEstimate,
  };
}
